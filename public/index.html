<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ULTIMATEFUTSERVICE CHAT</title>
  <style>
    :root {
      --primary: #00ffea;
      --bg-dark: #0a0f1f;
      --bg-light: #1a2238;
    }

    body {
      font-family: Arial, sans-serif;
      background: linear-gradient(145deg, var(--bg-dark), var(--bg-light));
      color: #fff;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      margin: 0;
      padding: 1rem;
    }

    h2 {
      text-align: center;
      margin-bottom: 1.5rem;
      color: var(--primary);
      font-size: 1.8rem;
    }

    #loginForm {
      background: rgba(0, 0, 0, 0.6);
      padding: 2rem;
      border-radius: 15px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.5);
      width: 100%;
      max-width: 400px;
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    input, select, button {
      padding: 12px;
      font-size: 1rem;
      border-radius: 8px;
      border: none;
      outline: none;
    }

    input, select {
      background: rgba(255,255,255,0.1);
      color: white;
      width: 100%;
    }

    input::placeholder {
      color: rgba(255,255,255,0.6);
    }

    select option {
      background: #1a2238;
      color: #fff;
    }

    button {
      background: var(--primary);
      color: #000;
      font-weight: bold;
      cursor: pointer;
      transition: transform 0.2s ease, background 0.3s ease;
    }

    button:hover {
      background: #00d4c2;
      transform: scale(1.03);
    }

    #chat {
      list-style: none;
      padding: 1rem;
      flex: 1;
      overflow-y: auto;
      margin: 1rem auto;
      background: rgba(0, 0, 0, 0.6);
      border-radius: 15px;
      width: 100%;
      max-width: 700px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    #chat li {
      padding: 10px;
      border-radius: 12px;
      max-width: 80%;
      word-wrap: break-word;
    }

    .client {
      background: #00ffea;
      color: #000;
      align-self: flex-start;
    }

    .player {
      background: #fff;
      color: #000;
      align-self: flex-end;
    }

    .admin {
      background: #ffcc00;
      color: #000;
      align-self: flex-end;
    }

    .time {
      font-size: 0.8em;
      color: rgba(255,255,255,0.7);
      margin-top: 5px;
    }

    #chatForm {
      display: none;
      width: 100%;
      max-width: 700px;
      display: flex;
      flex-direction: row;
      gap: 8px;
    }

    #msg {
      background: rgba(255,255,255,0.1);
      color: white;
      padding: 10px;
      border-radius: 8px;
      flex: 1;
    }

    #msg::placeholder {
      color: rgba(255,255,255,0.6);
    }

    #btnSend {
      background: var(--primary);
      color: #000;
      font-weight: bold;
      border-radius: 8px;
      padding: 10px 14px;
      flex-shrink: 0;
    }

    /* âœ… Responsive */
    @media (max-width: 768px) {
      body {
        padding: 0.8rem;
      }

      h2 {
        font-size: 1.4rem;
      }

      #loginForm {
        padding: 1.2rem;
        gap: 0.8rem;
      }

      input, select, button {
        font-size: 1rem;
      }

      #chat {
        max-height: 65vh;
      }

      #chatForm {
        flex-direction: column;
        gap: 6px;
      }

      #msg, #btnSend {
        width: 100%;
        font-size: 1rem;
      }
    }
  </style>
</head>
<body>
  <h2>ðŸ’¬ ULTIMATEFUTSERVICE Chat</h2>

  <div id="loginForm">
    <input id="chatIdInput" placeholder="Enter Order ID" autocomplete="off" />
    <select id="userTypeSelect">
      <option value="">Select your role</option>
      <option value="client">Client</option>
      <option value="player">Player</option>
      <option value="admin">Admin</option>
    </select>
    <input id="passwordInput" type="password" placeholder="Password (only player/admin)" style="display:none;" autocomplete="off" />
    <button id="btnEnter">Enter Chat</button>
  </div>

  <ul id="chat" style="display:none;"></ul>

  <form id="chatForm" style="display:none;">
    <input id="msg" placeholder="Type your message..." autocomplete="off" />
    <button id="btnSend" type="submit">Send</button>
  </form>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    // Use transports option to allow fallback to polling on flaky mobile networks
    const socket = io({ transports: ['websocket', 'polling'] });

    const chatIdInput = document.getElementById('chatIdInput');
    const userTypeSelect = document.getElementById('userTypeSelect');
    const passwordInput = document.getElementById('passwordInput');
    const btnEnter = document.getElementById('btnEnter');
    const chatUl = document.getElementById('chat');
    const msgInput = document.getElementById('msg');
    const btnSend = document.getElementById('btnSend');
    const loginForm = document.getElementById('loginForm');
    const chatForm = document.getElementById('chatForm');

    // keep session in localStorage so we can rejoin after reconnects
    let chatId = localStorage.getItem('ufs_chatId') || null;
    let userType = localStorage.getItem('ufs_userType') || null;
    let savedPassword = localStorage.getItem('ufs_password') || '';

    // if user already had a session, attempt rejoin on load/connect
    if (chatId && userType) {
      // populate fields (optional)
      chatIdInput.value = chatId;
      userTypeSelect.value = userType;
      passwordInput.value = savedPassword;
      // try to rejoin
      joinChat(chatId, userType, savedPassword);
    }

    userTypeSelect.addEventListener('change', () => {
      passwordInput.style.display = (userTypeSelect.value === 'player' || userTypeSelect.value === 'admin') ? 'block' : 'none';
    });

    btnEnter.addEventListener('click', () => {
      chatId = chatIdInput.value.trim();
      userType = userTypeSelect.value;
      const password = passwordInput.value || '';

      if (!chatId) return alert('You must enter an Order ID.');
      if (!['client', 'player', 'admin'].includes(userType)) return alert('Please select a valid role.');

      // save for reconnection
      localStorage.setItem('ufs_chatId', chatId);
      localStorage.setItem('ufs_userType', userType);
      localStorage.setItem('ufs_password', password);

      // Request notification permission on explicit action (less likely to be blocked)
      if (Notification && Notification.permission !== "granted") {
        Notification.requestPermission().catch(()=>{/* ignore */});
      }

      joinChat(chatId, userType, password);
    });

    function joinChat(id, type, password) {
      // emit join
      socket.emit('joinChat', { type, id, password });

      // clear any previous listeners to avoid duplicates
      socket.off('errorMsg');
      socket.off('joined');

      socket.once('errorMsg', (msg) => {
        alert(msg);
        // if error (e.g. wrong password) remove saved session to avoid infinite rejoin attempts
        localStorage.removeItem('ufs_chatId');
        localStorage.removeItem('ufs_userType');
        localStorage.removeItem('ufs_password');
      });

      socket.once('joined', (data) => {
        if (data.success) {
          loginForm.style.display = 'none';
          chatUl.style.display = 'flex';
          chatForm.style.display = 'flex';
          // load history fresh
          loadHistory();
        }
      });
    }

    function showMessage(msg) {
      const li = document.createElement('li');
      let cls = 'client';
      if (msg.author && msg.author.includes('Player')) cls = 'player';
      if (msg.author === 'Admin') cls = 'admin';
      li.className = cls;
      li.innerHTML = `<strong>${msg.author}</strong><br>${msg.text}<div class="time">${new Date(msg.time).toLocaleString()}</div>`;
      chatUl.appendChild(li);
      chatUl.scrollTop = chatUl.scrollHeight;
    }

    async function loadHistory() {
      if (!chatId) return;
      try {
        const res = await fetch(`/chat/${encodeURIComponent(chatId)}`);
        const messages = await res.json();
        chatUl.innerHTML = ''; // fresh
        messages.forEach(showMessage);
      } catch (err) {
        console.error('Error loading history', err);
        alert('Error loading history');
      }
    }

    // receive messages
    socket.on('receiveMessage', (msg) => {
      showMessage(msg);
      // show notification only if permission granted
      try {
        if (Notification && Notification.permission === "granted") {
          new Notification("ðŸ’¬ New message", {
            body: `${msg.author}: ${msg.text}`,
            icon: "/icon.jpg"
          });
        }
      } catch (e) {
        // some browsers require construction in user gesture; swallow errors
        console.warn('Notification error', e);
      }
    });

    // handle reconnects: if socket reconnects, rejoin room automatically
    socket.on('connect', () => {
      console.log('socket connected', socket.id);
      // if we have stored session, rejoin
      const storedId = localStorage.getItem('ufs_chatId');
      const storedType = localStorage.getItem('ufs_userType');
      const storedPass = localStorage.getItem('ufs_password') || '';
      if (storedId && storedType) {
        console.log('Rejoining chat after connect...');
        joinChat(storedId, storedType, storedPass);
      }
    });

    socket.on('connect_error', (err) => {
      console.warn('Socket connect_error', err);
    });

    socket.on('disconnect', (reason) => {
      console.log('Socket disconnected:', reason);
      // do not clear localStorage here â€” we will try to rejoin on next connect
    });

    // submit handler (works well on iPhone)
    chatForm.addEventListener('submit', (e) => {
      e.preventDefault();
      send();
    });

    function send() {
      const msg = msgInput.value.trim();
      if (!msg) return;
      // ensure socket is connected; if not, it will auto-reconnect and we rejoin on connect
      if (!socket.connected) {
        // inform the user but still queue attempt (socket.io buffers emits)
        console.warn('Socket not connected, attempting to reconnect and will send shortly');
        socket.connect();
      }
      socket.emit('sendMessage', msg);
      msgInput.value = '';
      msgInput.focus();

      // short vibration on mobile
      if (navigator.vibrate) navigator.vibrate(30);
    }
  </script>
</body>
</html>
